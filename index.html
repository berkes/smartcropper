<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Smartcropper for Ruby</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Smartcropper for Ruby</h1>
        <p>Content aware cropping for Ruby and Carrierwave</p>
        <p class="view"><a href="https://github.com/berkes/smartcropper">View the Project on GitHub <small>berkes/smartcropper</small></a></p>
        <ul>
          <li><a href="https://github.com/berkes/smartcropper/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/berkes/smartcropper/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/berkes/smartcropper">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>Smartcropper</h1>
<p>Crops images based on entropy: leaving the most interesting part intact.</p>

<p>Best results achieved in combination with scaling: the cropping is then only used to square the image, cutting off the least interesting part. 
The trimming simply chops off te edge that is least interesting, and continues doing so, untill it reached the requested size.</p>

<h2>Usage</h2>

<pre><code>gem install smartcropper</code></pre>
Or add to you bundle file.

<p>With <a href="https://github.com/jnicklas/carrierwave">carrierwave</a>, you use it in a custom <code>manipulate!</code> block. For example, carrierwave in a Rails project:</p>

<p>File <em>uploaders/attachement_uploader.rb</em>: </p>

<pre><code>def smart_crop_and_scale(width, height)
  manipulate! do |img|
    img = SmartCropper.new(img)
    img = img.smart_crop_and_scale(width, height)
    img = yield(img) if block_given?
    img
  end
end

# Create different versions of your uploaded files:
# A square and tiny thumbnail
version :thumb do
  process :smart_crop_and_scale =&gt; [80, 80]
end
# A large version, only cropped
version :preview do
  processs :crop =&gt; [200,400]
end
# A square version
version :cover do
  process :smart_square
end
</code></pre>

<p>With custom code, you simply create an instance of <em>SmartCropper</em></p>

<pre><code>
image = Magick::ImageList("carice.jpg")
SmartCropper.new(image).smart_square.write("carice_square.jpg")

# Or, simpler
SmartCropper.from_file("carice.jpg").smart_square.write("carice_square.jpg")
</code></pre>


<h2>Examples</h2>

Below some examples, generated with <a href="https://gist.github.com/4161796">this script</a>.

<div class="group">
       <figure>
        <figcaption>original</figcaption>
        <img src="ts_orig.jpg" alt="original" />
       </figure>
       <figure>
        <figcaption>smart_crop 400, 300</figcaption>
        <img src="ts_smart_crop.jpg" alt="smart_crop 400, 300" />
       </figure>
       <figure>
        <figcaption>smart_crop_and_scale 400, 300</figcaption>
        <img src="ts_smart_crop_and_scale.jpg" alt="smart_crop_and_scale 400, 300" />
       </figure>
       <figure>
        <figcaption>smart_square</figcaption>
        <img src="ts_smart_square.jpg" alt="smart_square" />
       </figure></div>
<div class="group">
       <figure>
        <figcaption>original</figcaption>
        <img src="sikh_orig.jpg" alt="original" />
       </figure>
       <figure>
        <figcaption>smart_crop 400, 300</figcaption>
        <img src="sikh_smart_crop.jpg" alt="smart_crop 400, 300" />
       </figure>
       <figure>
        <figcaption>smart_crop_and_scale 400, 300</figcaption>
        <img src="sikh_smart_crop_and_scale.jpg" alt="smart_crop_and_scale 400, 300" />
       </figure>
       <figure>
        <figcaption>smart_square</figcaption>
        <img src="sikh_smart_square.jpg" alt="smart_square" />
       </figure></div>
<div class="group">
       <figure>
        <figcaption>original</figcaption>
        <img src="carice_orig.jpg" alt="original" />
       </figure>
       <figure>
        <figcaption>smart_crop 400, 300</figcaption>
        <img src="carice_smart_crop.jpg" alt="smart_crop 400, 300" />
       </figure>
       <figure>
        <figcaption>smart_crop_and_scale 400, 300</figcaption>
        <img src="carice_smart_crop_and_scale.jpg" alt="smart_crop_and_scale 400, 300" />
       </figure>
       <figure>
        <figcaption>smart_square</figcaption>
        <img src="carice_smart_square.jpg" alt="smart_square" />
       </figure></div>
<div class="group">
       <figure>
        <figcaption>original</figcaption>
        <img src="banksy_orig.jpg" alt="original" />
       </figure>
       <figure>
        <figcaption>smart_crop 400, 300</figcaption>
        <img src="banksy_smart_crop.jpg" alt="smart_crop 400, 300" />
       </figure>
       <figure>
        <figcaption>smart_crop_and_scale 400, 300</figcaption>
        <img src="banksy_smart_crop_and_scale.jpg" alt="smart_crop_and_scale 400, 300" />
       </figure>
       <figure>
        <figcaption>smart_square</figcaption>
        <img src="banksy_smart_square.jpg" alt="smart_square" />
       </figure></div>
<br class="clear"/>

<h2>Workings</h2>
<p>Smartcropper grabs a slice from both outer sides of the image. It compares the entropy of the slices and then removes the slice with the lowest entropy. More differentiating pixels (colors, shadows, depth) indicates a more interesting part of the image; a higher entropy.
<figure>
  <figcaption>Vertical map of the entropy</figcaption>
  <img src="ts_entropy_map_vertical.jpg" alt="entropy map vertical" />
</figure>
</p>
<p>It then repeats that for the top-and bottom
<figure>
  <figcaption>Horizontal map of the entropy</figcaption>
  <img src="ts_entropy_map_horizontal.jpg" alt="entropy map horizontal" />
</figure>
</p>
<p>As you can see, entropy of a slice is not a perfect measurement of the "interestingness". Some slices have a high entropy, not because they contain the focus of the image, but some other artifact, like a tree, a logo or a lot of reflecting water.</p>

<p>Attempts to scan the image, rather then shaving it, have been made. But the result is not much better, yet the performance is hundreds times worse.
<figure>
  <figcaption>Mapping the entropy</figcaption>
  <img src="ts_entropy_map.jpg" alt="entropy map" />
</figure>
</p>

<p>
For now, shaving suffices. But I want to re-investigate the scanning-method, combined with some simple statistics to determine hotspots in the image. Then the "hotness" and size of these hotspots can be used to determine the boundries of the "interesting part".<br />
The biggest hurdle, then, is to reduce memory-usage and amount of iterations; since the value of each pixel in an image must be loaded into memory and looped over, multiple times, you can image the performance for large-ish images.

</p>

      </section>
    </div>
    <footer>
      <p>Project maintained by <a href="https://github.com/berkes">berkes</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
   <!-- Piwik -->
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://piwik.webschuur.com/" : "http://piwik.webschuur.com/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 11);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://piwik.webschuur.com/piwik.php?idsite=11" style="border:0" alt="" /></p></noscript>
<!-- End Piwik Tracking Code --> 
  </body>
</html>
